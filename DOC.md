<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# ringbuffer

```go
import "github.com/fufuok/ringbuffer"
```

## Index

- [Variables](<#variables>)
- [type RingBuffer](<#type-ringbuffer>)
  - [func New(initialSize int, maxBufferSize ...int) *RingBuffer](<#func-new>)
  - [func NewFixed(initialSize int) *RingBuffer](<#func-newfixed>)
  - [func NewUnbounded(initialSize int) *RingBuffer](<#func-newunbounded>)
  - [func (r *RingBuffer) Capacity() int](<#func-ringbuffer-capacity>)
  - [func (r *RingBuffer) Discards() uint64](<#func-ringbuffer-discards>)
  - [func (r *RingBuffer) IsEmpty() bool](<#func-ringbuffer-isempty>)
  - [func (r *RingBuffer) LPeekN(n int) []T](<#func-ringbuffer-lpeekn>)
  - [func (r *RingBuffer) Len() int](<#func-ringbuffer-len>)
  - [func (r *RingBuffer) MaxSize() int](<#func-ringbuffer-maxsize>)
  - [func (r *RingBuffer) Peek() (T, error)](<#func-ringbuffer-peek>)
  - [func (r *RingBuffer) PeekAll() (buf []T)](<#func-ringbuffer-peekall>)
  - [func (r *RingBuffer) RPeekN(n int) []T](<#func-ringbuffer-rpeekn>)
  - [func (r *RingBuffer) Read() (T, error)](<#func-ringbuffer-read>)
  - [func (r *RingBuffer) Reset()](<#func-ringbuffer-reset>)
  - [func (r *RingBuffer) SetMaxSize(n int) int](<#func-ringbuffer-setmaxsize>)
  - [func (r *RingBuffer) SetOnDiscards(fn func(interface{}))](<#func-ringbuffer-setondiscards>)
  - [func (r *RingBuffer) Write(v T)](<#func-ringbuffer-write>)
- [type RingBufferOf](<#type-ringbufferof>)
  - [func NewFixedOf[T any](initialSize int) *RingBufferOf[T]](<#func-newfixedof>)
  - [func NewOf[T any](initialSize int, maxBufferSize ...int) *RingBufferOf[T]](<#func-newof>)
  - [func NewUnboundedOf[T any](initialSize int) *RingBufferOf[T]](<#func-newunboundedof>)
  - [func (r *RingBufferOf[T]) Capacity() int](<#func-ringbufferoft-capacity>)
  - [func (r *RingBufferOf[T]) Discards() uint64](<#func-ringbufferoft-discards>)
  - [func (r *RingBufferOf[T]) IsEmpty() bool](<#func-ringbufferoft-isempty>)
  - [func (r *RingBufferOf[T]) LPeekN(n int) []T](<#func-ringbufferoft-lpeekn>)
  - [func (r *RingBufferOf[T]) Len() int](<#func-ringbufferoft-len>)
  - [func (r *RingBufferOf[T]) MaxSize() int](<#func-ringbufferoft-maxsize>)
  - [func (r *RingBufferOf[T]) Peek() (T, error)](<#func-ringbufferoft-peek>)
  - [func (r *RingBufferOf[T]) PeekAll() (buf []T)](<#func-ringbufferoft-peekall>)
  - [func (r *RingBufferOf[T]) RPeekN(n int) []T](<#func-ringbufferoft-rpeekn>)
  - [func (r *RingBufferOf[T]) Read() (T, error)](<#func-ringbufferoft-read>)
  - [func (r *RingBufferOf[T]) Reset()](<#func-ringbufferoft-reset>)
  - [func (r *RingBufferOf[T]) SetMaxSize(n int) int](<#func-ringbufferoft-setmaxsize>)
  - [func (r *RingBufferOf[T]) SetOnDiscards(fn func(T))](<#func-ringbufferoft-setondiscards>)
  - [func (r *RingBufferOf[T]) Write(v T)](<#func-ringbufferoft-write>)
- [type T](<#type-t>)


## Variables

```go
var ErrIsEmpty = errors.New("ringbuffer is empty")
```

## type RingBuffer

RingBuffer is a ring buffer for common types. It is never full and always grows if it will be full. It is not thread\-safe\(goroutine\-safe\) so you must use the lock\-like synchronization primitive to use it in multiple writers and multiple readers. Exceeding maxSize, data will be discarded.

```go
type RingBuffer struct {
    // contains filtered or unexported fields
}
```

### func New

```go
func New(initialSize int, maxBufferSize ...int) *RingBuffer
```

### func NewFixed

```go
func NewFixed(initialSize int) *RingBuffer
```

### func NewUnbounded

```go
func NewUnbounded(initialSize int) *RingBuffer
```

### func \(\*RingBuffer\) Capacity

```go
func (r *RingBuffer) Capacity() int
```

Capacity returns the size of the underlying buffer.

### func \(\*RingBuffer\) Discards

```go
func (r *RingBuffer) Discards() uint64
```

### func \(\*RingBuffer\) IsEmpty

```go
func (r *RingBuffer) IsEmpty() bool
```

### func \(\*RingBuffer\) LPeekN

```go
func (r *RingBuffer) LPeekN(n int) []T
```

### func \(\*RingBuffer\) Len

```go
func (r *RingBuffer) Len() int
```

### func \(\*RingBuffer\) MaxSize

```go
func (r *RingBuffer) MaxSize() int
```

### func \(\*RingBuffer\) Peek

```go
func (r *RingBuffer) Peek() (T, error)
```

### func \(\*RingBuffer\) PeekAll

```go
func (r *RingBuffer) PeekAll() (buf []T)
```

### func \(\*RingBuffer\) RPeekN

```go
func (r *RingBuffer) RPeekN(n int) []T
```

### func \(\*RingBuffer\) Read

```go
func (r *RingBuffer) Read() (T, error)
```

### func \(\*RingBuffer\) Reset

```go
func (r *RingBuffer) Reset()
```

### func \(\*RingBuffer\) SetMaxSize

```go
func (r *RingBuffer) SetMaxSize(n int) int
```

### func \(\*RingBuffer\) SetOnDiscards

```go
func (r *RingBuffer) SetOnDiscards(fn func(interface{}))
```

### func \(\*RingBuffer\) Write

```go
func (r *RingBuffer) Write(v T)
```

## type RingBufferOf

RingBufferOf is a ring buffer for common types. It is never full and always grows if it will be full. It is not thread\-safe\(goroutine\-safe\) so you must use the lock\-like synchronization primitive to use it in multiple writers and multiple readers. Exceeding maxSize, data will be discarded.

```go
type RingBufferOf[T any] struct {
    // contains filtered or unexported fields
}
```

### func NewFixedOf

```go
func NewFixedOf[T any](initialSize int) *RingBufferOf[T]
```

### func NewOf

```go
func NewOf[T any](initialSize int, maxBufferSize ...int) *RingBufferOf[T]
```

### func NewUnboundedOf

```go
func NewUnboundedOf[T any](initialSize int) *RingBufferOf[T]
```

### func \(\*RingBufferOf\[T\]\) Capacity

```go
func (r *RingBufferOf[T]) Capacity() int
```

Capacity returns the size of the underlying buffer.

### func \(\*RingBufferOf\[T\]\) Discards

```go
func (r *RingBufferOf[T]) Discards() uint64
```

### func \(\*RingBufferOf\[T\]\) IsEmpty

```go
func (r *RingBufferOf[T]) IsEmpty() bool
```

### func \(\*RingBufferOf\[T\]\) LPeekN

```go
func (r *RingBufferOf[T]) LPeekN(n int) []T
```

### func \(\*RingBufferOf\[T\]\) Len

```go
func (r *RingBufferOf[T]) Len() int
```

### func \(\*RingBufferOf\[T\]\) MaxSize

```go
func (r *RingBufferOf[T]) MaxSize() int
```

### func \(\*RingBufferOf\[T\]\) Peek

```go
func (r *RingBufferOf[T]) Peek() (T, error)
```

### func \(\*RingBufferOf\[T\]\) PeekAll

```go
func (r *RingBufferOf[T]) PeekAll() (buf []T)
```

### func \(\*RingBufferOf\[T\]\) RPeekN

```go
func (r *RingBufferOf[T]) RPeekN(n int) []T
```

### func \(\*RingBufferOf\[T\]\) Read

```go
func (r *RingBufferOf[T]) Read() (T, error)
```

### func \(\*RingBufferOf\[T\]\) Reset

```go
func (r *RingBufferOf[T]) Reset()
```

### func \(\*RingBufferOf\[T\]\) SetMaxSize

```go
func (r *RingBufferOf[T]) SetMaxSize(n int) int
```

### func \(\*RingBufferOf\[T\]\) SetOnDiscards

```go
func (r *RingBufferOf[T]) SetOnDiscards(fn func(T))
```

### func \(\*RingBufferOf\[T\]\) Write

```go
func (r *RingBufferOf[T]) Write(v T)
```

## type T

```go
type T interface{}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
